{"ast":null,"code":"import { CHANNEL_FETCH_CHANNEL, CHANNEL_FETCH_CHANNEL_SUCCESS, CHANNEL_FETCH_CHANNEL_ERROR, CHANNEL_SET_ACTIVE_CHANNEL, fetchChannelData, fetchSuccessChannelData, fetchErrorChannelData, CHANNEL_RESET_CHANNEL_DATA } from \"data/redux/action/channel\";\nimport { updateObject } from \"data/util\";\nimport Channel from \"data/redux/model/Channel\";\nimport { find as _find, map as _map, toString as _toString } from \"lodash\";\nconst initialStateChannel = {\n  channelList: [],\n  activeChannel: null,\n  channelLoading: false\n};\n\nfunction fetchSuccess(channelState, response) {\n  const data = response.data,\n        activeChannelId = response.activeChannelId;\n\n  let channelList = _map(data, result => new Channel(result));\n\n  let activeChannel = _find(channelList, channel => _toString(channel.id) === activeChannelId);\n\n  return updateObject(channelState, {\n    channelList: channelList,\n    activeChannel: activeChannel,\n    channelLoading: false\n  });\n}\n\nfunction setActiveChannel(channelState, channelId) {\n  let activeChannel = null;\n  channelState.channelList.map(channel => {\n    if (\"\" + channel.id === channelId) {\n      activeChannel = channel;\n    }\n  });\n  return updateObject(channelState, {\n    activeChannel: activeChannel\n  });\n}\n\nexport default function (channelState = initialStateChannel, action) {\n  switch (action.type) {\n    case CHANNEL_RESET_CHANNEL_DATA:\n      return updateObject(channelState, initialStateChannel);\n\n    case CHANNEL_SET_ACTIVE_CHANNEL:\n      return setActiveChannel(channelState, action.channelId);\n\n    case CHANNEL_FETCH_CHANNEL:\n      return updateObject(channelState, {\n        channelLoading: true\n      });\n\n    case CHANNEL_FETCH_CHANNEL_SUCCESS:\n      return fetchSuccess(channelState, action.data);\n\n    default:\n      return channelState;\n  }\n}","map":{"version":3,"sources":["/Users/nhnent/IdeaProjects/moobe/src/main/webapps/moobe-fe/src/data/redux/reducers/channelReducer.js"],"names":["CHANNEL_FETCH_CHANNEL","CHANNEL_FETCH_CHANNEL_SUCCESS","CHANNEL_FETCH_CHANNEL_ERROR","CHANNEL_SET_ACTIVE_CHANNEL","fetchChannelData","fetchSuccessChannelData","fetchErrorChannelData","CHANNEL_RESET_CHANNEL_DATA","updateObject","Channel","find","_find","map","_map","toString","_toString","initialStateChannel","channelList","activeChannel","channelLoading","fetchSuccess","channelState","response","data","activeChannelId","result","channel","id","setActiveChannel","channelId","action","type"],"mappings":"AAAA,SACIA,qBADJ,EAEIC,6BAFJ,EAGIC,2BAHJ,EAIIC,0BAJJ,EAKIC,gBALJ,EAMIC,uBANJ,EAOIC,qBAPJ,EAO2BC,0BAP3B,QAQO,2BARP;AASA,SAASC,YAAT,QAA4B,WAA5B;AACA,OAAOC,OAAP,MAAoB,0BAApB;AACA,SAAQC,IAAI,IAAIC,KAAhB,EAAuBC,GAAG,IAAIC,IAA9B,EAAoCC,QAAQ,IAAIC,SAAhD,QAAgE,QAAhE;AAEA,MAAMC,mBAAmB,GAAG;AACxBC,EAAAA,WAAW,EAAE,EADW;AAExBC,EAAAA,aAAa,EAAE,IAFS;AAGxBC,EAAAA,cAAc,EAAE;AAHQ,CAA5B;;AAMA,SAASC,YAAT,CAAsBC,YAAtB,EAAoCC,QAApC,EAA8C;AAAA,QACnCC,IADmC,GACVD,QADU,CACnCC,IADmC;AAAA,QAC7BC,eAD6B,GACVF,QADU,CAC7BE,eAD6B;;AAE1C,MAAIP,WAAW,GAAGJ,IAAI,CAACU,IAAD,EAAOE,MAAM,IAAI,IAAIhB,OAAJ,CAAYgB,MAAZ,CAAjB,CAAtB;;AACA,MAAIP,aAAa,GAAGP,KAAK,CAACM,WAAD,EAAeS,OAAD,IAAaX,SAAS,CAACW,OAAO,CAACC,EAAT,CAAT,KAA0BH,eAArD,CAAzB;;AACA,SAAOhB,YAAY,CAACa,YAAD,EAAe;AAACJ,IAAAA,WAAW,EAAEA,WAAd;AAA2BC,IAAAA,aAAa,EAAEA,aAA1C;AAAyDC,IAAAA,cAAc,EAAE;AAAzE,GAAf,CAAnB;AACH;;AAED,SAASS,gBAAT,CAA0BP,YAA1B,EAAwCQ,SAAxC,EAAmD;AAC/C,MAAIX,aAAa,GAAG,IAApB;AACAG,EAAAA,YAAY,CAACJ,WAAb,CAAyBL,GAAzB,CAA6Bc,OAAO,IAAI;AACpC,QAAG,KAAKA,OAAO,CAACC,EAAb,KAAoBE,SAAvB,EAAkC;AAC9BX,MAAAA,aAAa,GAAGQ,OAAhB;AACH;AACJ,GAJD;AAMA,SAAOlB,YAAY,CAACa,YAAD,EAAe;AAACH,IAAAA,aAAa,EAAEA;AAAhB,GAAf,CAAnB;AACH;;AAED,eAAe,UAASG,YAAY,GAAGL,mBAAxB,EAA6Cc,MAA7C,EAAqD;AAChE,UAAOA,MAAM,CAACC,IAAd;AACI,SAAKxB,0BAAL;AAAkC,aAAOC,YAAY,CAACa,YAAD,EAAeL,mBAAf,CAAnB;;AAClC,SAAKb,0BAAL;AAAkC,aAAOyB,gBAAgB,CAACP,YAAD,EAAeS,MAAM,CAACD,SAAtB,CAAvB;;AAClC,SAAK7B,qBAAL;AAA6B,aAAOQ,YAAY,CAACa,YAAD,EAAe;AAACF,QAAAA,cAAc,EAAE;AAAjB,OAAf,CAAnB;;AAC7B,SAAKlB,6BAAL;AAAqC,aAAOmB,YAAY,CAACC,YAAD,EAAeS,MAAM,CAACP,IAAtB,CAAnB;;AACrC;AAAU,aAAOF,YAAP;AALd;AAOH","sourcesContent":["import {\n    CHANNEL_FETCH_CHANNEL,\n    CHANNEL_FETCH_CHANNEL_SUCCESS,\n    CHANNEL_FETCH_CHANNEL_ERROR,\n    CHANNEL_SET_ACTIVE_CHANNEL,\n    fetchChannelData,\n    fetchSuccessChannelData,\n    fetchErrorChannelData, CHANNEL_RESET_CHANNEL_DATA,\n} from \"data/redux/action/channel\";\nimport { updateObject} from \"data/util\";\nimport Channel from \"data/redux/model/Channel\";\nimport {find as _find, map as _map, toString as _toString} from \"lodash\";\n\nconst initialStateChannel = {\n    channelList: [],\n    activeChannel: null,\n    channelLoading: false\n};\n\nfunction fetchSuccess(channelState, response) {\n    const {data, activeChannelId} = response;\n    let channelList = _map(data, result => new Channel(result));\n    let activeChannel = _find(channelList, (channel) => _toString(channel.id) === activeChannelId);\n    return updateObject(channelState, {channelList: channelList, activeChannel: activeChannel, channelLoading: false})\n}\n\nfunction setActiveChannel(channelState, channelId) {\n    let activeChannel = null;\n    channelState.channelList.map(channel => {\n        if(\"\" + channel.id === channelId) {\n            activeChannel = channel;\n        }\n    });\n\n    return updateObject(channelState, {activeChannel: activeChannel})\n}\n\nexport default function(channelState = initialStateChannel, action) {\n    switch(action.type) {\n        case CHANNEL_RESET_CHANNEL_DATA : return updateObject(channelState, initialStateChannel);\n        case CHANNEL_SET_ACTIVE_CHANNEL : return setActiveChannel(channelState, action.channelId);\n        case CHANNEL_FETCH_CHANNEL : return updateObject(channelState, {channelLoading: true});\n        case CHANNEL_FETCH_CHANNEL_SUCCESS : return fetchSuccess(channelState, action.data);\n        default : return channelState;\n    }\n}\n\n\n"]},"metadata":{},"sourceType":"module"}